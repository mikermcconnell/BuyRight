'use client';\n\nimport React, { \n  useState, \n  useEffect, \n  useRef, \n  useCallback, \n  useMemo,\n  Suspense,\n  lazy\n} from 'react';\nimport { motion, useReducedMotion } from 'framer-motion';\nimport { useInView } from 'framer-motion';\n\n// Lazy Loading Image Component with Intersection Observer\ninterface LazyImageProps {\n  src: string;\n  alt: string;\n  className?: string;\n  placeholder?: string;\n  onLoad?: () => void;\n  onError?: () => void;\n  priority?: boolean;\n  sizes?: string;\n}\n\nexport function LazyImage({\n  src,\n  alt,\n  className = '',\n  placeholder = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIHZpZXdCb3g9XCIwIDAgMTAwIDEwMFwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPgo8cmVjdCB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIGZpbGw9XCIjRjNGNEY2XCIvPgo8L3N2Zz4K',\n  onLoad,\n  onError,\n  priority = false,\n  sizes,\n}: LazyImageProps) {\n  const [isLoaded, setIsLoaded] = useState(false);\n  const [isError, setIsError] = useState(false);\n  const [imageSrc, setImageSrc] = useState(priority ? src : placeholder);\n  const imgRef = useRef<HTMLImageElement>(null);\n  const isInView = useInView(imgRef, { once: true, margin: '100px' });\n  const shouldReduceMotion = useReducedMotion();\n\n  useEffect(() => {\n    if ((isInView || priority) && imageSrc === placeholder) {\n      const img = new Image();\n      img.onload = () => {\n        setImageSrc(src);\n        setIsLoaded(true);\n        onLoad?.();\n      };\n      img.onerror = () => {\n        setIsError(true);\n        onError?.();\n      };\n      img.src = src;\n    }\n  }, [isInView, priority, src, placeholder, imageSrc, onLoad, onError]);\n\n  return (\n    <div className={`relative overflow-hidden ${className}`}>\n      <motion.img\n        ref={imgRef}\n        src={imageSrc}\n        alt={alt}\n        sizes={sizes}\n        className=\"w-full h-full object-cover\"\n        initial={shouldReduceMotion ? {} : { opacity: 0, scale: 1.1 }}\n        animate={shouldReduceMotion ? {} : {\n          opacity: isLoaded ? 1 : 0,\n          scale: isLoaded ? 1 : 1.1\n        }}\n        transition={shouldReduceMotion ? {} : { duration: 0.6, ease: \"easeOut\" }}\n        loading={priority ? 'eager' : 'lazy'}\n        decoding=\"async\"\n      />\n      \n      {/* Loading state */}\n      {!isLoaded && !isError && (\n        <div className=\"absolute inset-0 bg-gray-200 animate-pulse flex items-center justify-center\">\n          <div className=\"w-8 h-8 bg-gray-300 rounded animate-pulse\" />\n        </div>\n      )}\n      \n      {/* Error state */}\n      {isError && (\n        <div className=\"absolute inset-0 bg-gray-100 flex items-center justify-center\">\n          <div className=\"text-center text-gray-400\">\n            <div className=\"w-8 h-8 bg-gray-300 rounded mx-auto mb-2\" />\n            <span className=\"text-xs\">Failed to load</span>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n\n// Virtualized List for Large Datasets\ninterface VirtualizedListProps<T> {\n  items: T[];\n  itemHeight: number;\n  renderItem: (item: T, index: number) => React.ReactNode;\n  containerHeight: number;\n  className?: string;\n  overscan?: number;\n}\n\nexport function VirtualizedList<T>({\n  items,\n  itemHeight,\n  renderItem,\n  containerHeight,\n  className = '',\n  overscan = 5,\n}: VirtualizedListProps<T>) {\n  const [scrollTop, setScrollTop] = useState(0);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {\n    setScrollTop(e.currentTarget.scrollTop);\n  }, []);\n\n  const { startIndex, endIndex, offsetY } = useMemo(() => {\n    const visibleStart = Math.floor(scrollTop / itemHeight);\n    const visibleEnd = Math.min(\n      items.length - 1,\n      Math.ceil((scrollTop + containerHeight) / itemHeight)\n    );\n    \n    return {\n      startIndex: Math.max(0, visibleStart - overscan),\n      endIndex: Math.min(items.length - 1, visibleEnd + overscan),\n      offsetY: Math.max(0, visibleStart - overscan) * itemHeight,\n    };\n  }, [scrollTop, itemHeight, containerHeight, items.length, overscan]);\n\n  const visibleItems = useMemo(() => {\n    const result = [];\n    for (let i = startIndex; i <= endIndex; i++) {\n      result.push({\n        index: i,\n        item: items[i],\n      });\n    }\n    return result;\n  }, [items, startIndex, endIndex]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={`overflow-auto ${className}`}\n      style={{ height: containerHeight }}\n      onScroll={handleScroll}\n    >\n      <div\n        style={{\n          height: items.length * itemHeight,\n          position: 'relative',\n        }}\n      >\n        <div\n          style={{\n            transform: `translateY(${offsetY}px)`,\n            position: 'absolute',\n            width: '100%',\n          }}\n        >\n          {visibleItems.map(({ item, index }) => (\n            <div\n              key={index}\n              style={{\n                height: itemHeight,\n                display: 'flex',\n                alignItems: 'center',\n              }}\n            >\n              {renderItem(item, index)}\n            </div>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n}\n\n// Debounced Input for Performance\ninterface DebouncedInputProps {\n  value: string;\n  onChange: (value: string) => void;\n  delay?: number;\n  placeholder?: string;\n  className?: string;\n  onFocus?: () => void;\n  onBlur?: () => void;\n}\n\nexport function DebouncedInput({\n  value,\n  onChange,\n  delay = 300,\n  placeholder,\n  className = '',\n  onFocus,\n  onBlur,\n}: DebouncedInputProps) {\n  const [localValue, setLocalValue] = useState(value);\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Sync with external value changes\n  useEffect(() => {\n    setLocalValue(value);\n  }, [value]);\n\n  // Debounced onChange\n  useEffect(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    \n    timeoutRef.current = setTimeout(() => {\n      if (localValue !== value) {\n        onChange(localValue);\n      }\n    }, delay);\n\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, [localValue, onChange, delay, value]);\n\n  return (\n    <input\n      type=\"text\"\n      value={localValue}\n      onChange={(e) => setLocalValue(e.target.value)}\n      placeholder={placeholder}\n      className={`\n        w-full px-4 py-3 border border-gray-300 rounded-xl\n        focus:ring-4 focus:ring-primary-200 focus:border-primary-500\n        transition-all duration-200\n        ${className}\n      `}\n      onFocus={onFocus}\n      onBlur={onBlur}\n    />\n  );\n}\n\n// Intersection Observer Hook for Lazy Loading\nexport function useIntersectionObserver(\n  elementRef: React.RefObject<Element>,\n  options: IntersectionObserverInit = {}\n) {\n  const [isIntersecting, setIsIntersecting] = useState(false);\n  const [hasIntersected, setHasIntersected] = useState(false);\n\n  useEffect(() => {\n    const element = elementRef.current;\n    if (!element) return;\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        const isElementIntersecting = entry.isIntersecting;\n        setIsIntersecting(isElementIntersecting);\n        \n        if (isElementIntersecting && !hasIntersected) {\n          setHasIntersected(true);\n        }\n      },\n      {\n        threshold: 0.1,\n        rootMargin: '50px',\n        ...options,\n      }\n    );\n\n    observer.observe(element);\n\n    return () => {\n      observer.unobserve(element);\n    };\n  }, [elementRef, hasIntersected, options]);\n\n  return { isIntersecting, hasIntersected };\n}\n\n// Memoized Card Component\ninterface OptimizedCardProps {\n  title: string;\n  description: string;\n  imageUrl?: string;\n  onClick?: () => void;\n  className?: string;\n  loading?: boolean;\n}\n\nexport const OptimizedCard = React.memo(function OptimizedCard({\n  title,\n  description,\n  imageUrl,\n  onClick,\n  className = '',\n  loading = false,\n}: OptimizedCardProps) {\n  const cardRef = useRef<HTMLDivElement>(null);\n  const { hasIntersected } = useIntersectionObserver(cardRef);\n  const shouldReduceMotion = useReducedMotion();\n\n  // Only render expensive content when visible\n  const content = useMemo(() => {\n    if (!hasIntersected && !loading) {\n      return (\n        <div className=\"animate-pulse\">\n          <div className=\"h-48 bg-gray-200 rounded-t-xl\" />\n          <div className=\"p-6\">\n            <div className=\"h-4 bg-gray-200 rounded mb-3\" />\n            <div className=\"h-3 bg-gray-200 rounded mb-2\" />\n            <div className=\"h-3 bg-gray-200 rounded w-3/4\" />\n          </div>\n        </div>\n      );\n    }\n\n    return (\n      <>\n        {imageUrl && (\n          <div className=\"h-48 overflow-hidden rounded-t-xl\">\n            <LazyImage\n              src={imageUrl}\n              alt={title}\n              className=\"w-full h-full\"\n              sizes=\"(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw\"\n            />\n          </div>\n        )}\n        <div className=\"p-6\">\n          <h3 className=\"font-semibold text-lg text-gray-900 mb-2 line-clamp-2\">\n            {title}\n          </h3>\n          <p className=\"text-gray-600 text-sm line-clamp-3\">\n            {description}\n          </p>\n        </div>\n      </>\n    );\n  }, [hasIntersected, loading, imageUrl, title, description]);\n\n  return (\n    <motion.div\n      ref={cardRef}\n      className={`\n        bg-white rounded-xl shadow-md hover:shadow-lg transition-all duration-200\n        cursor-pointer overflow-hidden\n        ${className}\n      `}\n      onClick={onClick}\n      initial={shouldReduceMotion ? {} : { opacity: 0, y: 20 }}\n      animate={shouldReduceMotion ? {} : {\n        opacity: hasIntersected ? 1 : 0,\n        y: hasIntersected ? 0 : 20\n      }}\n      transition={shouldReduceMotion ? {} : { duration: 0.6, ease: \"easeOut\" }}\n      whileHover={shouldReduceMotion ? {} : { y: -4, scale: 1.02 }}\n      whileTap={shouldReduceMotion ? {} : { scale: 0.98 }}\n    >\n      {content}\n    </motion.div>\n  );\n});\n\n// Performance Monitoring Hook\nexport function usePerformanceMonitor() {\n  const [metrics, setMetrics] = useState({\n    renderTime: 0,\n    componentCount: 0,\n  });\n\n  useEffect(() => {\n    let startTime = performance.now();\n    let componentCount = 0;\n\n    // Count React components\n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        if (mutation.type === 'childList') {\n          componentCount += mutation.addedNodes.length;\n        }\n      });\n    });\n\n    observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n    });\n\n    const updateMetrics = () => {\n      const renderTime = performance.now() - startTime;\n      setMetrics({ renderTime, componentCount });\n    };\n\n    // Update metrics after render\n    const timeoutId = setTimeout(updateMetrics, 100);\n\n    return () => {\n      observer.disconnect();\n      clearTimeout(timeoutId);\n    };\n  }, []);\n\n  return metrics;\n}\n\n// Optimized Animation Wrapper\ninterface OptimizedAnimationProps {\n  children: React.ReactNode;\n  animation?: 'fade' | 'slide' | 'scale' | 'none';\n  delay?: number;\n  className?: string;\n}\n\nexport function OptimizedAnimation({\n  children,\n  animation = 'fade',\n  delay = 0,\n  className = '',\n}: OptimizedAnimationProps) {\n  const shouldReduceMotion = useReducedMotion();\n  const ref = useRef<HTMLDivElement>(null);\n  const isInView = useInView(ref, { once: true, margin: '50px' });\n\n  // Skip animations if user prefers reduced motion\n  if (shouldReduceMotion || animation === 'none') {\n    return <div className={className}>{children}</div>;\n  }\n\n  const animations = {\n    fade: {\n      initial: { opacity: 0 },\n      animate: { opacity: 1 },\n    },\n    slide: {\n      initial: { opacity: 0, y: 20 },\n      animate: { opacity: 1, y: 0 },\n    },\n    scale: {\n      initial: { opacity: 0, scale: 0.9 },\n      animate: { opacity: 1, scale: 1 },\n    },\n  };\n\n  return (\n    <motion.div\n      ref={ref}\n      className={className}\n      initial={animations[animation].initial}\n      animate={isInView ? animations[animation].animate : animations[animation].initial}\n      transition={{\n        duration: 0.6,\n        delay,\n        ease: [0.25, 0.4, 0.25, 1],\n      }}\n    >\n      {children}\n    </motion.div>\n  );\n}\n\n// Bundle Size Warning Component (Development Only)\nexport function BundleSizeWarning() {\n  if (process.env.NODE_ENV !== 'development') {\n    return null;\n  }\n\n  const [bundleSize, setBundleSize] = useState<number | null>(null);\n\n  useEffect(() => {\n    // Estimate bundle size based on loaded resources\n    const resources = performance.getEntriesByType('resource') as PerformanceResourceTiming[];\n    const jsResources = resources.filter(r => \n      r.name.includes('.js') && \n      r.transferSize > 0\n    );\n    \n    const totalSize = jsResources.reduce((acc, resource) => {\n      return acc + (resource.transferSize || 0);\n    }, 0);\n    \n    setBundleSize(Math.round(totalSize / 1024)); // Convert to KB\n  }, []);\n\n  if (!bundleSize || bundleSize < 250) {\n    return null;\n  }\n\n  return (\n    <div className=\"fixed bottom-4 left-4 bg-orange-100 border-l-4 border-orange-500 p-4 shadow-lg rounded z-50 max-w-sm\">\n      <div className=\"flex items-center\">\n        <div className=\"flex-shrink-0\">\n          <span className=\"text-orange-500 text-lg\">⚠️</span>\n        </div>\n        <div className=\"ml-3\">\n          <p className=\"text-sm font-medium text-orange-800\">\n            Bundle Size Warning\n          </p>\n          <p className=\"text-xs text-orange-700 mt-1\">\n            Current bundle: ~{bundleSize}KB. Consider code splitting for better performance.\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n}\n\n// Web Vitals Reporter\nexport function WebVitalsReporter() {\n  useEffect(() => {\n    if (process.env.NODE_ENV === 'development') {\n      import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n        getCLS(console.log);\n        getFID(console.log);\n        getFCP(console.log);\n        getLCP(console.log);\n        getTTFB(console.log);\n      });\n    }\n  }, []);\n\n  return null;\n}"